use crate::token::Token;

// AST nodes
use crate::ast;
use crate::ast::IdentNode;
use crate::ast::value::{ValueType, ValueNode};

pub struct Parser {
    pos: usize,

    /// Tokens generated by the lexer
    tokens: Vec<Token>
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Parser {
        Parser {
            pos: 0,
            tokens: tokens
        }
    }

    fn advance(&mut self) {
        self.pos += 1
    }

    fn is_eos(&self) -> bool {
        self.pos >= self.tokens.len()
    }

    fn peek(&self) -> Token {
        // clone to get the value *not* a borrow
        self.tokens.get(self.pos).cloned().unwrap()
    }

    pub fn parse_ident(&mut self) -> IdentNode {
        let token = self.peek();
        let mut name = String::new();

        if let Token::Identifier(v) = token {
            name = v;
        }

        let node = IdentNode::new(name);
        self.advance();
        node
    }

    pub fn parse_number(&mut self) -> ValueNode<i32> {
        let token = self.peek();
        let mut value = 0;

        // No support for floating point numbers yet
        if let Token::IntLit(v) = token {
            value = v;
        }

        let node = ValueNode::new(ValueType::Integer, value);
        //println!("{:?}", node);

        self.advance();
        node
    }

    pub fn parse_string(&mut self) -> ValueNode<String> {
        let token = self.peek();
        let mut value = String::new();

        if let Token::StringLit(v) = token {
            value = v;
        }

        let node = ValueNode::new(ValueType::StringLit, value);
        self.advance();
        node
    }
}
